//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IClient {
    /**
     * @return Success
     */
    aboutsAll(): Observable<About[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    aboutsPOST(body?: About | undefined): Observable<About>;
    /**
     * @return Success
     */
    aboutsGET(id: number): Observable<About>;
    /**
     * @param body (optional) 
     * @return Success
     */
    aboutsPUT(id: number, body?: About | undefined): Observable<void>;
    /**
     * @return Success
     */
    aboutsDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    cartItemsAll(): Observable<CartItem[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    cartItemsPOST(body?: CartItem | undefined): Observable<CartItem>;
    /**
     * @return Success
     */
    cartItemsGET(id: number): Observable<CartItem>;
    /**
     * @param body (optional) 
     * @return Success
     */
    cartItemsPUT(id: number, body?: CartItem | undefined): Observable<void>;
    /**
     * @return Success
     */
    cartItemsDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    cartsAll(): Observable<Cart[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    cartsPOST(body?: Cart | undefined): Observable<Cart>;
    /**
     * @return Success
     */
    cartsGET(id: number): Observable<Cart>;
    /**
     * @param body (optional) 
     * @return Success
     */
    cartsPUT(id: number, body?: Cart | undefined): Observable<void>;
    /**
     * @return Success
     */
    cartsDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    categoriesAll(): Observable<Category[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    categoriesPOST(body?: Category | undefined): Observable<Category>;
    /**
     * @return Success
     */
    categoriesGET(id: number): Observable<Category>;
    /**
     * @param body (optional) 
     * @return Success
     */
    categoriesPUT(id: number, body?: Category | undefined): Observable<void>;
    /**
     * @return Success
     */
    categoriesDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    commentsAll(): Observable<Comment[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    commentsPOST(body?: Comment | undefined): Observable<Comment>;
    /**
     * @return Success
     */
    commentsGET(id: number): Observable<Comment>;
    /**
     * @param body (optional) 
     * @return Success
     */
    commentsPUT(id: number, body?: Comment | undefined): Observable<void>;
    /**
     * @return Success
     */
    commentsDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    couponsAll(): Observable<Coupon[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    couponsPOST(body?: Coupon | undefined): Observable<Coupon>;
    /**
     * @return Success
     */
    couponsGET(id: number): Observable<Coupon>;
    /**
     * @param body (optional) 
     * @return Success
     */
    couponsPUT(id: number, body?: Coupon | undefined): Observable<void>;
    /**
     * @return Success
     */
    couponsDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    favoritesAll(): Observable<Favorite[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    favoritesPOST(body?: Favorite | undefined): Observable<Favorite>;
    /**
     * @return Success
     */
    favoritesGET(id: number): Observable<Favorite>;
    /**
     * @param body (optional) 
     * @return Success
     */
    favoritesPUT(id: number, body?: Favorite | undefined): Observable<void>;
    /**
     * @return Success
     */
    favoritesDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    feedBacksAll(): Observable<FeedBack[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    feedBacksPOST(body?: FeedBack | undefined): Observable<FeedBack>;
    /**
     * @return Success
     */
    feedBacksGET(id: number): Observable<FeedBack>;
    /**
     * @param body (optional) 
     * @return Success
     */
    feedBacksPUT(id: number, body?: FeedBack | undefined): Observable<void>;
    /**
     * @return Success
     */
    feedBacksDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    paymentsAll(): Observable<Payment[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    paymentsPOST(body?: Payment | undefined): Observable<Payment>;
    /**
     * @return Success
     */
    paymentsGET(id: number): Observable<Payment>;
    /**
     * @param body (optional) 
     * @return Success
     */
    paymentsPUT(id: number, body?: Payment | undefined): Observable<void>;
    /**
     * @return Success
     */
    paymentsDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    productsAll(): Observable<Product[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    productsPOST(body?: Product | undefined): Observable<Product>;
    /**
     * @return Success
     */
    productsGET(id: number): Observable<Product>;
    /**
     * @param body (optional) 
     * @return Success
     */
    productsPUT(id: number, body?: Product | undefined): Observable<void>;
    /**
     * @return Success
     */
    productsDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    rolesAll(): Observable<Role[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    rolesPOST(body?: Role | undefined): Observable<Role>;
    /**
     * @return Success
     */
    rolesGET(id: number): Observable<Role>;
    /**
     * @param body (optional) 
     * @return Success
     */
    rolesPUT(id: number, body?: Role | undefined): Observable<void>;
    /**
     * @return Success
     */
    rolesDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    salesAll(): Observable<Sale[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    salesPOST(body?: Sale | undefined): Observable<Sale>;
    /**
     * @return Success
     */
    salesGET(id: number): Observable<Sale>;
    /**
     * @param body (optional) 
     * @return Success
     */
    salesPUT(id: number, body?: Sale | undefined): Observable<void>;
    /**
     * @return Success
     */
    salesDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    sizeProductsAll(): Observable<SizeProduct[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    sizeProductsPOST(body?: SizeProduct | undefined): Observable<SizeProduct>;
    /**
     * @return Success
     */
    sizeProductsGET(id: number): Observable<SizeProduct>;
    /**
     * @param body (optional) 
     * @return Success
     */
    sizeProductsPUT(id: number, body?: SizeProduct | undefined): Observable<void>;
    /**
     * @return Success
     */
    sizeProductsDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    slidersAll(): Observable<Slider[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    slidersPOST(body?: Slider | undefined): Observable<Slider>;
    /**
     * @return Success
     */
    slidersGET(id: number): Observable<Slider>;
    /**
     * @param body (optional) 
     * @return Success
     */
    slidersPUT(id: number, body?: Slider | undefined): Observable<void>;
    /**
     * @return Success
     */
    slidersDELETE(id: number): Observable<void>;
    /**
     * @return Success
     */
    usersAll(): Observable<User[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    usersPOST(body?: User | undefined): Observable<User>;
    /**
     * @return Success
     */
    usersGET(id: number): Observable<User>;
    /**
     * @param body (optional) 
     * @return Success
     */
    usersPUT(id: number, body?: User | undefined): Observable<void>;
    /**
     * @return Success
     */
    usersDELETE(id: number): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class Client implements IClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    aboutsAll(): Observable<About[]> {
        let url_ = this.baseUrl + "/api/v1/Abouts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAboutsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAboutsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<About[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<About[]>;
        }));
    }

    protected processAboutsAll(response: HttpResponseBase): Observable<About[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(About.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<About[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    aboutsPOST(body?: About | undefined): Observable<About> {
        let url_ = this.baseUrl + "/api/v1/Abouts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAboutsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAboutsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<About>;
                }
            } else
                return _observableThrow(response_) as any as Observable<About>;
        }));
    }

    protected processAboutsPOST(response: HttpResponseBase): Observable<About> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = About.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<About>(null as any);
    }

    /**
     * @return Success
     */
    aboutsGET(id: number): Observable<About> {
        let url_ = this.baseUrl + "/api/v1/Abouts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAboutsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAboutsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<About>;
                }
            } else
                return _observableThrow(response_) as any as Observable<About>;
        }));
    }

    protected processAboutsGET(response: HttpResponseBase): Observable<About> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = About.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<About>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    aboutsPUT(id: number, body?: About | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Abouts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAboutsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAboutsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAboutsPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    aboutsDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Abouts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAboutsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAboutsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAboutsDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    cartItemsAll(): Observable<CartItem[]> {
        let url_ = this.baseUrl + "/api/v1/CartItems";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCartItemsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCartItemsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CartItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CartItem[]>;
        }));
    }

    protected processCartItemsAll(response: HttpResponseBase): Observable<CartItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CartItem.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CartItem[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cartItemsPOST(body?: CartItem | undefined): Observable<CartItem> {
        let url_ = this.baseUrl + "/api/v1/CartItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCartItemsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCartItemsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CartItem>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CartItem>;
        }));
    }

    protected processCartItemsPOST(response: HttpResponseBase): Observable<CartItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = CartItem.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CartItem>(null as any);
    }

    /**
     * @return Success
     */
    cartItemsGET(id: number): Observable<CartItem> {
        let url_ = this.baseUrl + "/api/v1/CartItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCartItemsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCartItemsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CartItem>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CartItem>;
        }));
    }

    protected processCartItemsGET(response: HttpResponseBase): Observable<CartItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = CartItem.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CartItem>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cartItemsPUT(id: number, body?: CartItem | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/CartItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCartItemsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCartItemsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCartItemsPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    cartItemsDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/CartItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCartItemsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCartItemsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCartItemsDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    cartsAll(): Observable<Cart[]> {
        let url_ = this.baseUrl + "/api/v1/Carts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCartsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCartsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Cart[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Cart[]>;
        }));
    }

    protected processCartsAll(response: HttpResponseBase): Observable<Cart[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Cart.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Cart[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cartsPOST(body?: Cart | undefined): Observable<Cart> {
        let url_ = this.baseUrl + "/api/v1/Carts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCartsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCartsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Cart>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Cart>;
        }));
    }

    protected processCartsPOST(response: HttpResponseBase): Observable<Cart> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Cart.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Cart>(null as any);
    }

    /**
     * @return Success
     */
    cartsGET(id: number): Observable<Cart> {
        let url_ = this.baseUrl + "/api/v1/Carts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCartsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCartsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Cart>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Cart>;
        }));
    }

    protected processCartsGET(response: HttpResponseBase): Observable<Cart> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Cart.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Cart>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cartsPUT(id: number, body?: Cart | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Carts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCartsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCartsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCartsPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    cartsDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Carts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCartsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCartsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCartsDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    categoriesAll(): Observable<Category[]> {
        let url_ = this.baseUrl + "/api/v1/Categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Category[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Category[]>;
        }));
    }

    protected processCategoriesAll(response: HttpResponseBase): Observable<Category[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Category.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Category[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    categoriesPOST(body?: Category | undefined): Observable<Category> {
        let url_ = this.baseUrl + "/api/v1/Categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Category>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Category>;
        }));
    }

    protected processCategoriesPOST(response: HttpResponseBase): Observable<Category> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Category>(null as any);
    }

    /**
     * @return Success
     */
    categoriesGET(id: number): Observable<Category> {
        let url_ = this.baseUrl + "/api/v1/Categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Category>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Category>;
        }));
    }

    protected processCategoriesGET(response: HttpResponseBase): Observable<Category> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Category>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    categoriesPUT(id: number, body?: Category | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCategoriesPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    categoriesDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCategoriesDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    commentsAll(): Observable<Comment[]> {
        let url_ = this.baseUrl + "/api/v1/Comments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Comment[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Comment[]>;
        }));
    }

    protected processCommentsAll(response: HttpResponseBase): Observable<Comment[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Comment.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Comment[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    commentsPOST(body?: Comment | undefined): Observable<Comment> {
        let url_ = this.baseUrl + "/api/v1/Comments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Comment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Comment>;
        }));
    }

    protected processCommentsPOST(response: HttpResponseBase): Observable<Comment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Comment.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Comment>(null as any);
    }

    /**
     * @return Success
     */
    commentsGET(id: number): Observable<Comment> {
        let url_ = this.baseUrl + "/api/v1/Comments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Comment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Comment>;
        }));
    }

    protected processCommentsGET(response: HttpResponseBase): Observable<Comment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Comment.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Comment>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    commentsPUT(id: number, body?: Comment | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Comments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCommentsPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    commentsDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Comments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCommentsDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    couponsAll(): Observable<Coupon[]> {
        let url_ = this.baseUrl + "/api/v1/Coupons";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCouponsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCouponsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Coupon[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Coupon[]>;
        }));
    }

    protected processCouponsAll(response: HttpResponseBase): Observable<Coupon[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Coupon.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Coupon[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    couponsPOST(body?: Coupon | undefined): Observable<Coupon> {
        let url_ = this.baseUrl + "/api/v1/Coupons";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCouponsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCouponsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Coupon>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Coupon>;
        }));
    }

    protected processCouponsPOST(response: HttpResponseBase): Observable<Coupon> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Coupon.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Coupon>(null as any);
    }

    /**
     * @return Success
     */
    couponsGET(id: number): Observable<Coupon> {
        let url_ = this.baseUrl + "/api/v1/Coupons/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCouponsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCouponsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Coupon>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Coupon>;
        }));
    }

    protected processCouponsGET(response: HttpResponseBase): Observable<Coupon> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Coupon.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Coupon>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    couponsPUT(id: number, body?: Coupon | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Coupons/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCouponsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCouponsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCouponsPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    couponsDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Coupons/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCouponsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCouponsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCouponsDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    favoritesAll(): Observable<Favorite[]> {
        let url_ = this.baseUrl + "/api/v1/Favorites";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFavoritesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFavoritesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Favorite[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Favorite[]>;
        }));
    }

    protected processFavoritesAll(response: HttpResponseBase): Observable<Favorite[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Favorite.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Favorite[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    favoritesPOST(body?: Favorite | undefined): Observable<Favorite> {
        let url_ = this.baseUrl + "/api/v1/Favorites";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFavoritesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFavoritesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Favorite>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Favorite>;
        }));
    }

    protected processFavoritesPOST(response: HttpResponseBase): Observable<Favorite> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Favorite.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Favorite>(null as any);
    }

    /**
     * @return Success
     */
    favoritesGET(id: number): Observable<Favorite> {
        let url_ = this.baseUrl + "/api/v1/Favorites/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFavoritesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFavoritesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Favorite>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Favorite>;
        }));
    }

    protected processFavoritesGET(response: HttpResponseBase): Observable<Favorite> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Favorite.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Favorite>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    favoritesPUT(id: number, body?: Favorite | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Favorites/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFavoritesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFavoritesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processFavoritesPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    favoritesDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Favorites/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFavoritesDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFavoritesDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processFavoritesDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    feedBacksAll(): Observable<FeedBack[]> {
        let url_ = this.baseUrl + "/api/v1/FeedBacks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeedBacksAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeedBacksAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FeedBack[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FeedBack[]>;
        }));
    }

    protected processFeedBacksAll(response: HttpResponseBase): Observable<FeedBack[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FeedBack.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FeedBack[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    feedBacksPOST(body?: FeedBack | undefined): Observable<FeedBack> {
        let url_ = this.baseUrl + "/api/v1/FeedBacks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeedBacksPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeedBacksPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FeedBack>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FeedBack>;
        }));
    }

    protected processFeedBacksPOST(response: HttpResponseBase): Observable<FeedBack> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = FeedBack.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FeedBack>(null as any);
    }

    /**
     * @return Success
     */
    feedBacksGET(id: number): Observable<FeedBack> {
        let url_ = this.baseUrl + "/api/v1/FeedBacks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeedBacksGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeedBacksGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FeedBack>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FeedBack>;
        }));
    }

    protected processFeedBacksGET(response: HttpResponseBase): Observable<FeedBack> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = FeedBack.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FeedBack>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    feedBacksPUT(id: number, body?: FeedBack | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/FeedBacks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeedBacksPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeedBacksPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processFeedBacksPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    feedBacksDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/FeedBacks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeedBacksDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeedBacksDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processFeedBacksDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    paymentsAll(): Observable<Payment[]> {
        let url_ = this.baseUrl + "/api/v1/Payments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Payment[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Payment[]>;
        }));
    }

    protected processPaymentsAll(response: HttpResponseBase): Observable<Payment[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Payment.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Payment[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paymentsPOST(body?: Payment | undefined): Observable<Payment> {
        let url_ = this.baseUrl + "/api/v1/Payments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Payment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Payment>;
        }));
    }

    protected processPaymentsPOST(response: HttpResponseBase): Observable<Payment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Payment.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Payment>(null as any);
    }

    /**
     * @return Success
     */
    paymentsGET(id: number): Observable<Payment> {
        let url_ = this.baseUrl + "/api/v1/Payments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Payment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Payment>;
        }));
    }

    protected processPaymentsGET(response: HttpResponseBase): Observable<Payment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Payment.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Payment>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paymentsPUT(id: number, body?: Payment | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Payments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPaymentsPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    paymentsDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Payments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPaymentsDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    productsAll(): Observable<Product[]> {
        let url_ = this.baseUrl + "/api/v1/Products";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product[]>;
        }));
    }

    protected processProductsAll(response: HttpResponseBase): Observable<Product[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Product.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    productsPOST(body?: Product | undefined): Observable<Product> {
        let url_ = this.baseUrl + "/api/v1/Products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product>;
        }));
    }

    protected processProductsPOST(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product>(null as any);
    }

    /**
     * @return Success
     */
    productsGET(id: number): Observable<Product> {
        let url_ = this.baseUrl + "/api/v1/Products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product>;
        }));
    }

    protected processProductsGET(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    productsPUT(id: number, body?: Product | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processProductsPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    productsDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processProductsDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    rolesAll(): Observable<Role[]> {
        let url_ = this.baseUrl + "/api/v1/Roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Role[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Role[]>;
        }));
    }

    protected processRolesAll(response: HttpResponseBase): Observable<Role[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Role.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Role[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolesPOST(body?: Role | undefined): Observable<Role> {
        let url_ = this.baseUrl + "/api/v1/Roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Role>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Role>;
        }));
    }

    protected processRolesPOST(response: HttpResponseBase): Observable<Role> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Role>(null as any);
    }

    /**
     * @return Success
     */
    rolesGET(id: number): Observable<Role> {
        let url_ = this.baseUrl + "/api/v1/Roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Role>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Role>;
        }));
    }

    protected processRolesGET(response: HttpResponseBase): Observable<Role> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Role>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolesPUT(id: number, body?: Role | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRolesPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    rolesDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolesDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolesDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRolesDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    salesAll(): Observable<Sale[]> {
        let url_ = this.baseUrl + "/api/v1/Sales";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Sale[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Sale[]>;
        }));
    }

    protected processSalesAll(response: HttpResponseBase): Observable<Sale[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Sale.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Sale[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    salesPOST(body?: Sale | undefined): Observable<Sale> {
        let url_ = this.baseUrl + "/api/v1/Sales";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Sale>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Sale>;
        }));
    }

    protected processSalesPOST(response: HttpResponseBase): Observable<Sale> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Sale.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Sale>(null as any);
    }

    /**
     * @return Success
     */
    salesGET(id: number): Observable<Sale> {
        let url_ = this.baseUrl + "/api/v1/Sales/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Sale>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Sale>;
        }));
    }

    protected processSalesGET(response: HttpResponseBase): Observable<Sale> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Sale.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Sale>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    salesPUT(id: number, body?: Sale | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Sales/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSalesPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    salesDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Sales/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSalesDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    sizeProductsAll(): Observable<SizeProduct[]> {
        let url_ = this.baseUrl + "/api/v1/SizeProducts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSizeProductsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSizeProductsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeProduct[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeProduct[]>;
        }));
    }

    protected processSizeProductsAll(response: HttpResponseBase): Observable<SizeProduct[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SizeProduct.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SizeProduct[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sizeProductsPOST(body?: SizeProduct | undefined): Observable<SizeProduct> {
        let url_ = this.baseUrl + "/api/v1/SizeProducts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSizeProductsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSizeProductsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeProduct>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeProduct>;
        }));
    }

    protected processSizeProductsPOST(response: HttpResponseBase): Observable<SizeProduct> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SizeProduct.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SizeProduct>(null as any);
    }

    /**
     * @return Success
     */
    sizeProductsGET(id: number): Observable<SizeProduct> {
        let url_ = this.baseUrl + "/api/v1/SizeProducts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSizeProductsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSizeProductsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeProduct>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeProduct>;
        }));
    }

    protected processSizeProductsGET(response: HttpResponseBase): Observable<SizeProduct> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SizeProduct.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SizeProduct>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sizeProductsPUT(id: number, body?: SizeProduct | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/SizeProducts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSizeProductsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSizeProductsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSizeProductsPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    sizeProductsDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/SizeProducts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSizeProductsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSizeProductsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSizeProductsDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    slidersAll(): Observable<Slider[]> {
        let url_ = this.baseUrl + "/api/v1/Sliders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSlidersAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSlidersAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Slider[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Slider[]>;
        }));
    }

    protected processSlidersAll(response: HttpResponseBase): Observable<Slider[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Slider.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Slider[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    slidersPOST(body?: Slider | undefined): Observable<Slider> {
        let url_ = this.baseUrl + "/api/v1/Sliders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSlidersPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSlidersPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Slider>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Slider>;
        }));
    }

    protected processSlidersPOST(response: HttpResponseBase): Observable<Slider> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Slider.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Slider>(null as any);
    }

    /**
     * @return Success
     */
    slidersGET(id: number): Observable<Slider> {
        let url_ = this.baseUrl + "/api/v1/Sliders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSlidersGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSlidersGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Slider>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Slider>;
        }));
    }

    protected processSlidersGET(response: HttpResponseBase): Observable<Slider> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Slider.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Slider>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    slidersPUT(id: number, body?: Slider | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Sliders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSlidersPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSlidersPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSlidersPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    slidersDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Sliders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSlidersDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSlidersDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSlidersDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    usersAll(): Observable<User[]> {
        let url_ = this.baseUrl + "/api/v1/Users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User[]>;
        }));
    }

    protected processUsersAll(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    usersPOST(body?: User | undefined): Observable<User> {
        let url_ = this.baseUrl + "/api/v1/Users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processUsersPOST(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(null as any);
    }

    /**
     * @return Success
     */
    usersGET(id: number): Observable<User> {
        let url_ = this.baseUrl + "/api/v1/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processUsersGET(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    usersPUT(id: number, body?: User | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUsersPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    usersDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUsersDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204 && status !== 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export class About implements IAbout {
    aboutId?: number;
    title?: string | undefined;
    metaTitle?: string | undefined;
    description?: string | undefined;
    image?: string | undefined;
    detail?: string | undefined;
    createdDate?: Date | undefined;
    createdBy?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescriptions?: string | undefined;
    status?: number | undefined;

    constructor(data?: IAbout) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.aboutId = _data["aboutId"];
            this.title = _data["title"];
            this.metaTitle = _data["metaTitle"];
            this.description = _data["description"];
            this.image = _data["image"];
            this.detail = _data["detail"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.metaKeywords = _data["metaKeywords"];
            this.metaDescriptions = _data["metaDescriptions"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any, _mappings?: any): About | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<About>(data, _mappings, About);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aboutId"] = this.aboutId;
        data["title"] = this.title;
        data["metaTitle"] = this.metaTitle;
        data["description"] = this.description;
        data["image"] = this.image;
        data["detail"] = this.detail;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["metaKeywords"] = this.metaKeywords;
        data["metaDescriptions"] = this.metaDescriptions;
        data["status"] = this.status;
        return data;
    }
}

export interface IAbout {
    aboutId?: number;
    title?: string | undefined;
    metaTitle?: string | undefined;
    description?: string | undefined;
    image?: string | undefined;
    detail?: string | undefined;
    createdDate?: Date | undefined;
    createdBy?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescriptions?: string | undefined;
    status?: number | undefined;
}

export class Cart implements ICart {
    cartId?: number;
    userId?: number | undefined;
    paymentId?: number | undefined;
    couponId?: number | undefined;
    fullName?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    country?: string | undefined;
    province?: string | undefined;
    city?: string | undefined;
    itemDiscount?: number | undefined;
    vat?: number | undefined;
    shipping?: number | undefined;
    total?: number | undefined;
    discount?: number | undefined;
    status?: number | undefined;
    createAt?: Date | undefined;
    content?: string | undefined;
    readonly cartItems?: CartItem[] | undefined;
    coupon?: Coupon;
    payment?: Payment;

    constructor(data?: ICart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.cartItems) {
                this.cartItems = [];
                for (let i = 0; i < data.cartItems.length; i++) {
                    let item = data.cartItems[i];
                    this.cartItems[i] = item && !(<any>item).toJSON ? new CartItem(item) : <CartItem>item;
                }
            }
            this.coupon = data.coupon && !(<any>data.coupon).toJSON ? new Coupon(data.coupon) : <Coupon>this.coupon;
            this.payment = data.payment && !(<any>data.payment).toJSON ? new Payment(data.payment) : <Payment>this.payment;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.cartId = _data["cartId"];
            this.userId = _data["userId"];
            this.paymentId = _data["paymentId"];
            this.couponId = _data["couponId"];
            this.fullName = _data["fullName"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.country = _data["country"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.itemDiscount = _data["itemDiscount"];
            this.vat = _data["vat"];
            this.shipping = _data["shipping"];
            this.total = _data["total"];
            this.discount = _data["discount"];
            this.status = _data["status"];
            this.createAt = _data["createAt"] ? new Date(_data["createAt"].toString()) : <any>undefined;
            this.content = _data["content"];
            if (Array.isArray(_data["cartItems"])) {
                (<any>this).cartItems = [] as any;
                for (let item of _data["cartItems"])
                    (<any>this).cartItems!.push(CartItem.fromJS(item, _mappings));
            }
            this.coupon = _data["coupon"] ? Coupon.fromJS(_data["coupon"], _mappings) : <any>undefined;
            this.payment = _data["payment"] ? Payment.fromJS(_data["payment"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): Cart | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Cart>(data, _mappings, Cart);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cartId"] = this.cartId;
        data["userId"] = this.userId;
        data["paymentId"] = this.paymentId;
        data["couponId"] = this.couponId;
        data["fullName"] = this.fullName;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["country"] = this.country;
        data["province"] = this.province;
        data["city"] = this.city;
        data["itemDiscount"] = this.itemDiscount;
        data["vat"] = this.vat;
        data["shipping"] = this.shipping;
        data["total"] = this.total;
        data["discount"] = this.discount;
        data["status"] = this.status;
        data["createAt"] = this.createAt ? this.createAt.toISOString() : <any>undefined;
        data["content"] = this.content;
        if (Array.isArray(this.cartItems)) {
            data["cartItems"] = [];
            for (let item of this.cartItems)
                data["cartItems"].push(item.toJSON());
        }
        data["coupon"] = this.coupon ? this.coupon.toJSON() : <any>undefined;
        data["payment"] = this.payment ? this.payment.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICart {
    cartId?: number;
    userId?: number | undefined;
    paymentId?: number | undefined;
    couponId?: number | undefined;
    fullName?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    country?: string | undefined;
    province?: string | undefined;
    city?: string | undefined;
    itemDiscount?: number | undefined;
    vat?: number | undefined;
    shipping?: number | undefined;
    total?: number | undefined;
    discount?: number | undefined;
    status?: number | undefined;
    createAt?: Date | undefined;
    content?: string | undefined;
    cartItems?: ICartItem[] | undefined;
    coupon?: ICoupon;
    payment?: IPayment;
}

export class CartItem implements ICartItem {
    cartItemId?: number;
    productId?: number | undefined;
    cartId?: number | undefined;
    price?: number | undefined;
    discount?: number | undefined;
    quantity?: number | undefined;
    createAt?: Date | undefined;
    content?: string | undefined;
    cart?: Cart;
    product?: Product;

    constructor(data?: ICartItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.cart = data.cart && !(<any>data.cart).toJSON ? new Cart(data.cart) : <Cart>this.cart;
            this.product = data.product && !(<any>data.product).toJSON ? new Product(data.product) : <Product>this.product;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.cartItemId = _data["cartItemId"];
            this.productId = _data["productId"];
            this.cartId = _data["cartId"];
            this.price = _data["price"];
            this.discount = _data["discount"];
            this.quantity = _data["quantity"];
            this.createAt = _data["createAt"] ? new Date(_data["createAt"].toString()) : <any>undefined;
            this.content = _data["content"];
            this.cart = _data["cart"] ? Cart.fromJS(_data["cart"], _mappings) : <any>undefined;
            this.product = _data["product"] ? Product.fromJS(_data["product"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): CartItem | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CartItem>(data, _mappings, CartItem);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cartItemId"] = this.cartItemId;
        data["productId"] = this.productId;
        data["cartId"] = this.cartId;
        data["price"] = this.price;
        data["discount"] = this.discount;
        data["quantity"] = this.quantity;
        data["createAt"] = this.createAt ? this.createAt.toISOString() : <any>undefined;
        data["content"] = this.content;
        data["cart"] = this.cart ? this.cart.toJSON() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICartItem {
    cartItemId?: number;
    productId?: number | undefined;
    cartId?: number | undefined;
    price?: number | undefined;
    discount?: number | undefined;
    quantity?: number | undefined;
    createAt?: Date | undefined;
    content?: string | undefined;
    cart?: ICart;
    product?: IProduct;
}

export class Category implements ICategory {
    categoryId?: number;
    name?: string | undefined;
    metaTitle?: string | undefined;
    seoTitle?: string | undefined;
    createdDate?: Date | undefined;
    createdBy?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescriptions?: string | undefined;
    status?: number | undefined;
    readonly products?: Product[] | undefined;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.products) {
                this.products = [];
                for (let i = 0; i < data.products.length; i++) {
                    let item = data.products[i];
                    this.products[i] = item && !(<any>item).toJSON ? new Product(item) : <Product>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.metaTitle = _data["metaTitle"];
            this.seoTitle = _data["seoTitle"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.metaKeywords = _data["metaKeywords"];
            this.metaDescriptions = _data["metaDescriptions"];
            this.status = _data["status"];
            if (Array.isArray(_data["products"])) {
                (<any>this).products = [] as any;
                for (let item of _data["products"])
                    (<any>this).products!.push(Product.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Category | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Category>(data, _mappings, Category);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["metaTitle"] = this.metaTitle;
        data["seoTitle"] = this.seoTitle;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["metaKeywords"] = this.metaKeywords;
        data["metaDescriptions"] = this.metaDescriptions;
        data["status"] = this.status;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategory {
    categoryId?: number;
    name?: string | undefined;
    metaTitle?: string | undefined;
    seoTitle?: string | undefined;
    createdDate?: Date | undefined;
    createdBy?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescriptions?: string | undefined;
    status?: number | undefined;
    products?: IProduct[] | undefined;
}

export class Comment implements IComment {
    commentId?: number;
    userId?: number | undefined;
    productId?: number | undefined;
    commentText?: string | undefined;
    createAt?: Date | undefined;
    product?: Product;
    user?: User;

    constructor(data?: IComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.product = data.product && !(<any>data.product).toJSON ? new Product(data.product) : <Product>this.product;
            this.user = data.user && !(<any>data.user).toJSON ? new User(data.user) : <User>this.user;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.commentId = _data["commentId"];
            this.userId = _data["userId"];
            this.productId = _data["productId"];
            this.commentText = _data["commentText"];
            this.createAt = _data["createAt"] ? new Date(_data["createAt"].toString()) : <any>undefined;
            this.product = _data["product"] ? Product.fromJS(_data["product"], _mappings) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): Comment | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Comment>(data, _mappings, Comment);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commentId"] = this.commentId;
        data["userId"] = this.userId;
        data["productId"] = this.productId;
        data["commentText"] = this.commentText;
        data["createAt"] = this.createAt ? this.createAt.toISOString() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IComment {
    commentId?: number;
    userId?: number | undefined;
    productId?: number | undefined;
    commentText?: string | undefined;
    createAt?: Date | undefined;
    product?: IProduct;
    user?: IUser;
}

export class Coupon implements ICoupon {
    couponId?: number;
    code?: string | undefined;
    count?: number | undefined;
    promotion?: number | undefined;
    describe?: string | undefined;
    readonly carts?: Cart[] | undefined;

    constructor(data?: ICoupon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.carts) {
                this.carts = [];
                for (let i = 0; i < data.carts.length; i++) {
                    let item = data.carts[i];
                    this.carts[i] = item && !(<any>item).toJSON ? new Cart(item) : <Cart>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.couponId = _data["couponId"];
            this.code = _data["code"];
            this.count = _data["count"];
            this.promotion = _data["promotion"];
            this.describe = _data["describe"];
            if (Array.isArray(_data["carts"])) {
                (<any>this).carts = [] as any;
                for (let item of _data["carts"])
                    (<any>this).carts!.push(Cart.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Coupon | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Coupon>(data, _mappings, Coupon);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["couponId"] = this.couponId;
        data["code"] = this.code;
        data["count"] = this.count;
        data["promotion"] = this.promotion;
        data["describe"] = this.describe;
        if (Array.isArray(this.carts)) {
            data["carts"] = [];
            for (let item of this.carts)
                data["carts"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICoupon {
    couponId?: number;
    code?: string | undefined;
    count?: number | undefined;
    promotion?: number | undefined;
    describe?: string | undefined;
    carts?: ICart[] | undefined;
}

export class Favorite implements IFavorite {
    favoriteId?: number;
    userId?: number | undefined;
    productId?: number | undefined;
    product?: Product;
    user?: User;

    constructor(data?: IFavorite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.product = data.product && !(<any>data.product).toJSON ? new Product(data.product) : <Product>this.product;
            this.user = data.user && !(<any>data.user).toJSON ? new User(data.user) : <User>this.user;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.favoriteId = _data["favoriteId"];
            this.userId = _data["userId"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"], _mappings) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): Favorite | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Favorite>(data, _mappings, Favorite);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["favoriteId"] = this.favoriteId;
        data["userId"] = this.userId;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFavorite {
    favoriteId?: number;
    userId?: number | undefined;
    productId?: number | undefined;
    product?: IProduct;
    user?: IUser;
}

export class FeedBack implements IFeedBack {
    feedbackId?: number;
    userId?: number | undefined;
    name?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    content?: string | undefined;
    status?: number | undefined;
    createdDate?: Date | undefined;
    user?: User;

    constructor(data?: IFeedBack) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.user = data.user && !(<any>data.user).toJSON ? new User(data.user) : <User>this.user;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.feedbackId = _data["feedbackId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.content = _data["content"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): FeedBack | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FeedBack>(data, _mappings, FeedBack);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feedbackId"] = this.feedbackId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["address"] = this.address;
        data["content"] = this.content;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFeedBack {
    feedbackId?: number;
    userId?: number | undefined;
    name?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    content?: string | undefined;
    status?: number | undefined;
    createdDate?: Date | undefined;
    user?: IUser;
}

export class Payment implements IPayment {
    paymentId?: number;
    paymentName?: string | undefined;
    readonly carts?: Cart[] | undefined;

    constructor(data?: IPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.carts) {
                this.carts = [];
                for (let i = 0; i < data.carts.length; i++) {
                    let item = data.carts[i];
                    this.carts[i] = item && !(<any>item).toJSON ? new Cart(item) : <Cart>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.paymentId = _data["paymentId"];
            this.paymentName = _data["paymentName"];
            if (Array.isArray(_data["carts"])) {
                (<any>this).carts = [] as any;
                for (let item of _data["carts"])
                    (<any>this).carts!.push(Cart.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Payment | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Payment>(data, _mappings, Payment);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["paymentName"] = this.paymentName;
        if (Array.isArray(this.carts)) {
            data["carts"] = [];
            for (let item of this.carts)
                data["carts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPayment {
    paymentId?: number;
    paymentName?: string | undefined;
    carts?: ICart[] | undefined;
}

export class Product implements IProduct {
    productId?: number;
    productCode?: string | undefined;
    productName?: string | undefined;
    metaTitle?: string | undefined;
    description?: string | undefined;
    productImage?: string | undefined;
    sizeId?: number | undefined;
    moreImages?: string | undefined;
    price?: number | undefined;
    includeVat?: number | undefined;
    quantity?: number | undefined;
    detail?: string | undefined;
    createdDate?: Date | undefined;
    createdBy?: string | undefined;
    categoryId?: number | undefined;
    metaKeywords?: string | undefined;
    metaDescriptions?: string | undefined;
    status?: number | undefined;
    viewCounts?: number | undefined;
    readonly cartItems?: CartItem[] | undefined;
    category?: Category;
    readonly comments?: Comment[] | undefined;
    readonly favorites?: Favorite[] | undefined;
    readonly sales?: Sale[] | undefined;
    size?: SizeProduct;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.cartItems) {
                this.cartItems = [];
                for (let i = 0; i < data.cartItems.length; i++) {
                    let item = data.cartItems[i];
                    this.cartItems[i] = item && !(<any>item).toJSON ? new CartItem(item) : <CartItem>item;
                }
            }
            this.category = data.category && !(<any>data.category).toJSON ? new Category(data.category) : <Category>this.category;
            if (data.comments) {
                this.comments = [];
                for (let i = 0; i < data.comments.length; i++) {
                    let item = data.comments[i];
                    this.comments[i] = item && !(<any>item).toJSON ? new Comment(item) : <Comment>item;
                }
            }
            if (data.favorites) {
                this.favorites = [];
                for (let i = 0; i < data.favorites.length; i++) {
                    let item = data.favorites[i];
                    this.favorites[i] = item && !(<any>item).toJSON ? new Favorite(item) : <Favorite>item;
                }
            }
            if (data.sales) {
                this.sales = [];
                for (let i = 0; i < data.sales.length; i++) {
                    let item = data.sales[i];
                    this.sales[i] = item && !(<any>item).toJSON ? new Sale(item) : <Sale>item;
                }
            }
            this.size = data.size && !(<any>data.size).toJSON ? new SizeProduct(data.size) : <SizeProduct>this.size;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.metaTitle = _data["metaTitle"];
            this.description = _data["description"];
            this.productImage = _data["productImage"];
            this.sizeId = _data["sizeId"];
            this.moreImages = _data["moreImages"];
            this.price = _data["price"];
            this.includeVat = _data["includeVat"];
            this.quantity = _data["quantity"];
            this.detail = _data["detail"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.categoryId = _data["categoryId"];
            this.metaKeywords = _data["metaKeywords"];
            this.metaDescriptions = _data["metaDescriptions"];
            this.status = _data["status"];
            this.viewCounts = _data["viewCounts"];
            if (Array.isArray(_data["cartItems"])) {
                (<any>this).cartItems = [] as any;
                for (let item of _data["cartItems"])
                    (<any>this).cartItems!.push(CartItem.fromJS(item, _mappings));
            }
            this.category = _data["category"] ? Category.fromJS(_data["category"], _mappings) : <any>undefined;
            if (Array.isArray(_data["comments"])) {
                (<any>this).comments = [] as any;
                for (let item of _data["comments"])
                    (<any>this).comments!.push(Comment.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["favorites"])) {
                (<any>this).favorites = [] as any;
                for (let item of _data["favorites"])
                    (<any>this).favorites!.push(Favorite.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["sales"])) {
                (<any>this).sales = [] as any;
                for (let item of _data["sales"])
                    (<any>this).sales!.push(Sale.fromJS(item, _mappings));
            }
            this.size = _data["size"] ? SizeProduct.fromJS(_data["size"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): Product | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Product>(data, _mappings, Product);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["metaTitle"] = this.metaTitle;
        data["description"] = this.description;
        data["productImage"] = this.productImage;
        data["sizeId"] = this.sizeId;
        data["moreImages"] = this.moreImages;
        data["price"] = this.price;
        data["includeVat"] = this.includeVat;
        data["quantity"] = this.quantity;
        data["detail"] = this.detail;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["categoryId"] = this.categoryId;
        data["metaKeywords"] = this.metaKeywords;
        data["metaDescriptions"] = this.metaDescriptions;
        data["status"] = this.status;
        data["viewCounts"] = this.viewCounts;
        if (Array.isArray(this.cartItems)) {
            data["cartItems"] = [];
            for (let item of this.cartItems)
                data["cartItems"].push(item.toJSON());
        }
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (Array.isArray(this.favorites)) {
            data["favorites"] = [];
            for (let item of this.favorites)
                data["favorites"].push(item.toJSON());
        }
        if (Array.isArray(this.sales)) {
            data["sales"] = [];
            for (let item of this.sales)
                data["sales"].push(item.toJSON());
        }
        data["size"] = this.size ? this.size.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProduct {
    productId?: number;
    productCode?: string | undefined;
    productName?: string | undefined;
    metaTitle?: string | undefined;
    description?: string | undefined;
    productImage?: string | undefined;
    sizeId?: number | undefined;
    moreImages?: string | undefined;
    price?: number | undefined;
    includeVat?: number | undefined;
    quantity?: number | undefined;
    detail?: string | undefined;
    createdDate?: Date | undefined;
    createdBy?: string | undefined;
    categoryId?: number | undefined;
    metaKeywords?: string | undefined;
    metaDescriptions?: string | undefined;
    status?: number | undefined;
    viewCounts?: number | undefined;
    cartItems?: ICartItem[] | undefined;
    category?: ICategory;
    comments?: IComment[] | undefined;
    favorites?: IFavorite[] | undefined;
    sales?: ISale[] | undefined;
    size?: ISizeProduct;
}

export class Role implements IRole {
    rolesId?: number;
    rolesName?: string | undefined;
    readonly users?: User[] | undefined;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.users) {
                this.users = [];
                for (let i = 0; i < data.users.length; i++) {
                    let item = data.users[i];
                    this.users[i] = item && !(<any>item).toJSON ? new User(item) : <User>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.rolesId = _data["rolesId"];
            this.rolesName = _data["rolesName"];
            if (Array.isArray(_data["users"])) {
                (<any>this).users = [] as any;
                for (let item of _data["users"])
                    (<any>this).users!.push(User.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Role | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Role>(data, _mappings, Role);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rolesId"] = this.rolesId;
        data["rolesName"] = this.rolesName;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRole {
    rolesId?: number;
    rolesName?: string | undefined;
    users?: IUser[] | undefined;
}

export class Sale implements ISale {
    saleId?: number;
    promotion?: number | undefined;
    describe?: string | undefined;
    status?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    productId?: number | undefined;
    product?: Product;

    constructor(data?: ISale) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.product = data.product && !(<any>data.product).toJSON ? new Product(data.product) : <Product>this.product;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.saleId = _data["saleId"];
            this.promotion = _data["promotion"];
            this.describe = _data["describe"];
            this.status = _data["status"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): Sale | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Sale>(data, _mappings, Sale);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["saleId"] = this.saleId;
        data["promotion"] = this.promotion;
        data["describe"] = this.describe;
        data["status"] = this.status;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISale {
    saleId?: number;
    promotion?: number | undefined;
    describe?: string | undefined;
    status?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    productId?: number | undefined;
    product?: IProduct;
}

export class SizeProduct implements ISizeProduct {
    sizeId?: number;
    sizeName?: string | undefined;
    readonly products?: Product[] | undefined;

    constructor(data?: ISizeProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.products) {
                this.products = [];
                for (let i = 0; i < data.products.length; i++) {
                    let item = data.products[i];
                    this.products[i] = item && !(<any>item).toJSON ? new Product(item) : <Product>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.sizeId = _data["sizeId"];
            this.sizeName = _data["sizeName"];
            if (Array.isArray(_data["products"])) {
                (<any>this).products = [] as any;
                for (let item of _data["products"])
                    (<any>this).products!.push(Product.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): SizeProduct | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SizeProduct>(data, _mappings, SizeProduct);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sizeId"] = this.sizeId;
        data["sizeName"] = this.sizeName;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISizeProduct {
    sizeId?: number;
    sizeName?: string | undefined;
    products?: IProduct[] | undefined;
}

export class Slider implements ISlider {
    slideId?: number;
    image?: string | undefined;
    link?: string | undefined;
    description?: string | undefined;
    createdDate?: Date | undefined;
    createdBy?: string | undefined;
    status?: number | undefined;

    constructor(data?: ISlider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.slideId = _data["slideId"];
            this.image = _data["image"];
            this.link = _data["link"];
            this.description = _data["description"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any, _mappings?: any): Slider | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Slider>(data, _mappings, Slider);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["slideId"] = this.slideId;
        data["image"] = this.image;
        data["link"] = this.link;
        data["description"] = this.description;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["status"] = this.status;
        return data;
    }
}

export interface ISlider {
    slideId?: number;
    image?: string | undefined;
    link?: string | undefined;
    description?: string | undefined;
    createdDate?: Date | undefined;
    createdBy?: string | undefined;
    status?: number | undefined;
}

export class User implements IUser {
    userId?: number;
    userName?: string | undefined;
    password?: string | undefined;
    fullName?: string | undefined;
    gender?: number | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    address?: string | undefined;
    rolesId?: number | undefined;
    status?: number | undefined;
    readonly comments?: Comment[] | undefined;
    readonly favorites?: Favorite[] | undefined;
    readonly feedBacks?: FeedBack[] | undefined;
    roles?: Role;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.comments) {
                this.comments = [];
                for (let i = 0; i < data.comments.length; i++) {
                    let item = data.comments[i];
                    this.comments[i] = item && !(<any>item).toJSON ? new Comment(item) : <Comment>item;
                }
            }
            if (data.favorites) {
                this.favorites = [];
                for (let i = 0; i < data.favorites.length; i++) {
                    let item = data.favorites[i];
                    this.favorites[i] = item && !(<any>item).toJSON ? new Favorite(item) : <Favorite>item;
                }
            }
            if (data.feedBacks) {
                this.feedBacks = [];
                for (let i = 0; i < data.feedBacks.length; i++) {
                    let item = data.feedBacks[i];
                    this.feedBacks[i] = item && !(<any>item).toJSON ? new FeedBack(item) : <FeedBack>item;
                }
            }
            this.roles = data.roles && !(<any>data.roles).toJSON ? new Role(data.roles) : <Role>this.roles;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.fullName = _data["fullName"];
            this.gender = _data["gender"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
            this.rolesId = _data["rolesId"];
            this.status = _data["status"];
            if (Array.isArray(_data["comments"])) {
                (<any>this).comments = [] as any;
                for (let item of _data["comments"])
                    (<any>this).comments!.push(Comment.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["favorites"])) {
                (<any>this).favorites = [] as any;
                for (let item of _data["favorites"])
                    (<any>this).favorites!.push(Favorite.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["feedBacks"])) {
                (<any>this).feedBacks = [] as any;
                for (let item of _data["feedBacks"])
                    (<any>this).feedBacks!.push(FeedBack.fromJS(item, _mappings));
            }
            this.roles = _data["roles"] ? Role.fromJS(_data["roles"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): User | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<User>(data, _mappings, User);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["fullName"] = this.fullName;
        data["gender"] = this.gender;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        data["rolesId"] = this.rolesId;
        data["status"] = this.status;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (Array.isArray(this.favorites)) {
            data["favorites"] = [];
            for (let item of this.favorites)
                data["favorites"].push(item.toJSON());
        }
        if (Array.isArray(this.feedBacks)) {
            data["feedBacks"] = [];
            for (let item of this.feedBacks)
                data["feedBacks"].push(item.toJSON());
        }
        data["roles"] = this.roles ? this.roles.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUser {
    userId?: number;
    userName?: string | undefined;
    password?: string | undefined;
    fullName?: string | undefined;
    gender?: number | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    address?: string | undefined;
    rolesId?: number | undefined;
    status?: number | undefined;
    comments?: IComment[] | undefined;
    favorites?: IFavorite[] | undefined;
    feedBacks?: IFeedBack[] | undefined;
    roles?: IRole;
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T | null {
  if (!mappings)
    mappings = [];
  if (!data)
    return null;

  const mappingIndexName = "__mappingIndex";
  if (data[mappingIndexName])
    return <T>mappings[data[mappingIndexName]].target;

  data[mappingIndexName] = mappings.length;

  let result: any = new type();
  mappings.push({ source: data, target: result });
  result.init(data, mappings);
  return result;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}